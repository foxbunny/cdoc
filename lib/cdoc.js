// Generated by CoffeeScript 1.6.3
var VERBOSE, a, buildToc, commentRe, empty, emptyLineRe, existsSync, extract, headingRe, indentedRe, isDir, isGlob, isSkippable, iter, log, matchGlob, mkdirSync, opts, processDir, processFile, processParagraph, processParagraphs, readFileSync, readdirSync, slug, sourceDir, statSync, targetDir, toArray, tocIntend, wrap, writeFileSync, _ref, _ref1;

_ref = require('fs'), readFileSync = _ref.readFileSync, writeFileSync = _ref.writeFileSync, readdirSync = _ref.readdirSync, statSync = _ref.statSync, existsSync = _ref.existsSync, mkdirSync = _ref.mkdirSync;

_ref1 = require('dahelpers'), toArray = _ref1.toArray, wrap = _ref1.wrap, slug = _ref1.slug, a = _ref1.a, iter = _ref1.iter, empty = _ref1.empty;

opts = require('optimist');

commentRe = /^ *(?:#|# (.*))$/;

emptyLineRe = /^\s*$/;

indentedRe = /^ {1,4}\S.*$/;

headingRe = /^(#+) (.*)$/;

VERBOSE = true;

extract = function(filename) {
  var contents, isComment, lineType, lines, paragraphs;
  contents = readFileSync(filename, {
    encoding: 'utf-8'
  });
  isComment = function(line) {
    return line.match(commentRe);
  };
  lineType = function(line) {
    if (!line) {
      return [null, 'source'];
    } else {
      line = line[1];
      if (line == null) {
        return [null, 'source'];
      } else if (line.match(emptyLineRe)) {
        return ['\n', 'empty'];
      } else if (line.match(headingRe)) {
        return [line, 'heading'];
      } else if (line.match(indentedRe)) {
        return [line, 'indented'];
      } else {
        return [line, 'normal'];
      }
    }
  };
  lines = iter(contents.split('\n'));
  paragraphs = [];
  lines.apply(lineType, isComment).slice((function() {
    var add, commit, lastSeen, paragraph;
    paragraph = [];
    lastSeen = null;
    commit = function() {
      if (empty(paragraph)) {
        return;
      }
      paragraphs.push({
        type: lastSeen,
        content: paragraph
      });
      return paragraph = [];
    };
    add = function(l) {
      return paragraph.push(l);
    };
    return function(line) {
      var type, _ref2;
      _ref2 = line, line = _ref2[0], type = _ref2[1];
      switch (type) {
        case 'source':
          commit();
          break;
        case 'empty':
          if (lastSeen === 'heading' || lastSeen === 'normal') {
            commit();
          } else {
            add(line);
          }
          break;
        case 'heading':
          lastSeen = 'heading';
          commit();
          add(line);
          break;
        case 'normal':
          lastSeen = 'normal';
          add(line);
          break;
        case 'indented':
          lastSeen = 'indented';
          add(line);
      }
    };
  })());
  return paragraphs;
};

processParagraph = function(_arg) {
  var content, hash, m, s, title, type;
  type = _arg.type, content = _arg.content;
  switch (type) {
    case 'heading':
      s = content.join(' ');
      m = s.match(headingRe);
      title = m[2];
      hash = slug(m[2]);
      return '\n' + m[1] + ' ' + a(title, {
        id: hash
      });
    case 'normal':
      return wrap(content.join(' '));
    case 'indented':
      return content.join('\n');
  }
};

processParagraphs = function(paragraphs) {
  var p;
  return ((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = paragraphs.length; _i < _len; _i++) {
      p = paragraphs[_i];
      _results.push(processParagraph(p));
    }
    return _results;
  })()).join('\n\n');
};

tocIntend = function(level) {
  return new Array((level - 1) * 2 + 2).join(' ');
};

buildToc = function(paragraphs) {
  var bullet, filterHeadings, joinContent, maxTocLevel, minTocLevel, toc;
  toc = '';
  minTocLevel = 2;
  maxTocLevel = 4;
  bullet = '*';
  paragraphs = iter(paragraphs);
  filterHeadings = function(p) {
    if (p.type === 'heading') {
      return p.content;
    } else {
      throw 'skip';
    }
  };
  joinContent = function(p) {
    var level, m, s, title;
    s = p.join(' ');
    m = s.match(headingRe);
    level = m[1].length;
    title = m[2];
    if (maxTocLevel < level || level < minTocLevel) {
      throw 'skip';
    }
    return [level, title];
  };
  paragraphs.apply(joinContent, filterHeadings).slice(function(_arg) {
    var hash, indent, level, title;
    level = _arg[0], title = _arg[1];
    indent = tocIntend(level - minTocLevel + 1);
    hash = slug(title);
    return toc += "" + indent + bullet + " [" + title + "](#" + hash + ")\n";
  });
  return toc;
};

processFile = function(filename) {
  var mkd, paragraphs;
  paragraphs = extract(filename);
  mkd = processParagraphs(paragraphs);
  if (mkd.indexOf('::TOC::') > -1) {
    mkd = mkd.replace('::TOC::', buildToc(paragraphs));
  }
  return mkd;
};

log = function(msg) {
  if (VERBOSE) {
    return console.log(msg);
  }
};

isDir = function(path) {
  return statSync(path).isDirectory();
};

isGlob = function(s) {
  return s.indexOf('*') > -1 || s.indexOf('?') > -1;
};

matchGlob = function(s, glob) {
  glob = glob.replace('*', '.*').replace('?', '.').replace('.', '\\.');
  return s.match(new RegExp(glob));
};

isSkippable = function(filename, skipList) {
  var skip, t, _i, _len;
  for (_i = 0, _len = skipList.length; _i < _len; _i++) {
    skip = skipList[_i];
    if (isGlob(skip)) {
      t = matchGlob(filename, skip);
    } else {
      t = filename === skip;
    }
    if (t) {
      return true;
    }
  }
  return false;
};

processDir = function(dir, target, skip) {
  var ext, f, index, mkd, name, path, targetPath, _i, _len;
  if (skip == null) {
    skip = [];
  }
  index = readdirSync(dir);
  if (!existsSync(target)) {
    mkdirSync(target);
  }
  for (_i = 0, _len = index.length; _i < _len; _i++) {
    f = index[_i];
    if (isSkippable(f, skip)) {
      log("Skipping ignored file " + f);
      continue;
    }
    path = "" + dir + "/" + f;
    log("Processing " + path);
    if (isDir(path)) {
      log("Entering directory " + path);
      processDir(path, "" + target + "/" + f, skip);
    } else {
      name = f.split('.').slice(0, -1).join('.');
      ext = f.split('.').slice(-1)[0];
      if (ext !== 'coffee') {
        log("Skipping non-CoffeeScript file " + path);
        continue;
      }
      mkd = processFile(path);
      targetPath = "" + target + "/" + name + ".mkd";
      log("Writing markdown to " + targetPath);
      writeFileSync(targetPath, mkd, {
        encoding: 'utf-8'
      });
    }
  }
};

opts = opts.usage(['Usage:', '    $0 [-q] [-i IGNORE ...] SOURCE_DIR DOCS_DIR', '    $0 [-h]', ''].join('\n')).alias('i', 'ignore').alias('q', 'quiet').alias('h', 'help').describe('i', 'Ignore IGNORE directory. This option can be ', 'specified multiple times and can include glob patterns.').describe('q', 'Do not log messages to STDOUT').describe('h', 'Show this help');

if (opts.argv.h) {
  console.log(opts.help());
  process.exit(0);
}

sourceDir = opts.argv._[0];

targetDir = opts.argv._[1];

if ((sourceDir == null) || (targetDir == null)) {
  console.log("You must specify source and target directories");
  console.log();
  console.log(opts.help());
  process.exit(1);
}

if (opts.argv.q) {
  VERBOSE = false;
}

processDir(sourceDir, targetDir, toArray(opts.argv.i));
