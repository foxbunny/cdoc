// Generated by LiveScript 1.2.0
/**!
 * @author Branko Vukelic <branko@brankovukelic.com>
 * @license MIT
 */
var ref$, readFileSync, writeFileSync, readdirSync, statSync, existsSync, mkdirSync, toArray, wrap, slug, a, iter, empty, commentRe, emptyLineRe, indentedRe, headingRe, utf8, cdoc;
ref$ = require('fs'), readFileSync = ref$.readFileSync, writeFileSync = ref$.writeFileSync, readdirSync = ref$.readdirSync, statSync = ref$.statSync, existsSync = ref$.existsSync, mkdirSync = ref$.mkdirSync;
ref$ = require('dahelpers'), toArray = ref$.toArray, wrap = ref$.wrap, slug = ref$.slug, a = ref$.a, iter = ref$.iter, empty = ref$.empty;
commentRe = /^ *(?:#|# (.*))$/;
emptyLineRe = /^\s*$/;
indentedRe = /^ {1,4}\S.*$/;
headingRe = /^(#+) (.*)$/;
utf8 = {
  encoding: 'utf8'
};
cdoc = module.exports;
cdoc.VERBOSE = true;
cdoc.isComment = function(line){
  return line.match(commentRe);
};
cdoc.lineType = function(line){
  if (line === null) {
    return [null, 'source'];
  } else {
    line = line[1];
    if (line === void 8) {
      return [null, 'source'];
    } else if (line.match(emptyLineRe)) {
      return ['\n', 'empty'];
    } else if (line.match(headingRe)) {
      return [line, 'heading'];
    } else if (line.match(indentedRe)) {
      return [line, 'indented'];
    } else {
      return [line, 'normal'];
    }
  }
};
cdoc.extract = function(filename){
  var contents, lines, paragraphs;
  contents = readFileSync(filename, utf8);
  lines = iter(contents.split('\n'));
  paragraphs = [];
  lines.apply(this.lineType, this.isComment).slice(function(){
    var paragraph, lastSeen, commit, add;
    paragraph = [];
    lastSeen = null;
    commit = function(){
      if (!empty(paragraph)) {
        paragraphs.push({
          type: lastSeen,
          content: paragraph
        });
        paragraph = [];
      }
    };
    add = function(l){
      paragraph.push(l);
    };
    return function(line){
      var ref$, type;
      ref$ = line, line = ref$[0], type = ref$[1];
      switch (type) {
      case 'source':
        commit();
        break;
      case 'empty':
        if (lastSeen === 'heading' || lastSeen === 'normal') {
          commit();
        } else {
          add(line);
        }
        break;
      case 'heading':
        lastSeen = 'heading';
        commit();
        add(line);
        break;
      case 'normal':
        lastSeen = 'normal';
        add(line);
        break;
      case 'indented':
        lastSeen = 'indented';
        add(line);
      }
    };
  }());
  return paragraphs;
};
cdoc.processParagraph = function(arg$){
  var type, content, s, m, title, hash;
  type = arg$.type, content = arg$.content;
  switch (type) {
  case 'heading':
    s = content.join(' ');
    m = s.match(headingRe);
    title = m[2];
    hash = slug(m[2]);
    return '\n' + m[1] + ' ' + a(title, {
      id: hash
    });
  case 'normal':
    return wrap(content.join(' '));
  case 'indented':
    return content.join('\n');
  }
};
cdoc.processParagraphs = function(paragraphs){
  var p;
  return (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = paragraphs).length; i$ < len$; ++i$) {
      p = ref$[i$];
      results$.push(this.processParagraph(p));
    }
    return results$;
  }.call(this)).join('\n\n');
};
cdoc.tocIndent = function(level){
  return new Array((level - 1) * 2 + 2).join(' ');
};
cdoc.buildToc = function(paragraphs){
  var minTocLevel, maxTocLevel, bullet, toc, filterHeadings, joinContent, this$ = this;
  minTocLevel = 2;
  maxTocLevel = 4;
  bullet = '*';
  toc = '';
  paragraphs = iter(paragraphs);
  filterHeadings = function(p){
    if (p.type === 'heading') {
      return p.content;
    } else {
      throw 'skip';
    }
  };
  joinContent = function(p){
    var s, m, level, title;
    s = p.join(' ');
    m = s.match(headingRe);
    level = m[1].length;
    title = m[2];
    if (maxTocLevel < level || level < minTocLevel) {
      throw 'skip';
    }
    return [level, title];
  };
  paragraphs.apply(joinContent, filterHeadings).slice(function(arg$){
    var level, title, indent, hash;
    level = arg$[0], title = arg$[1];
    indent = this$.tocIndent(level - minTocLevel + 1);
    hash = slug(title);
    return toc += indent + "" + bullet + " [" + title + "](#" + hash + ")\n";
  });
  return toc;
};
cdoc.processFile = function(filename){
  var paragraphs, mkd;
  paragraphs = this.extract(filename);
  mkd = this.processParagraphs(paragraphs);
  if (mkd.indexOf('::TOC::') > -1) {
    mkd = mkd.replace('::TOC::', this.buildToc(paragraphs));
  }
  return mkd;
};
cdoc.log = function(msg){
  if (this.VERBOSE) {
    return console.log(msg);
  }
};
cdoc.isDir = function(path){
  return statSync(path).isDirectory();
};
cdoc.isGlob = function(s){
  return s.indexOf('*') > -1 || s.indexOf('?') > -1;
};
cdoc.matchGlob = function(s, glob){
  glob = glob.replace('*', '.*').replace('?', '.').replace('.', '\\.');
  return s.match(new RegExp(glob));
};
cdoc.isSkippable = function(filename, skipList){
  var i$, len$, skip, t;
  for (i$ = 0, len$ = skipList.length; i$ < len$; ++i$) {
    skip = skipList[i$];
    if (isGlob(skip)) {
      t = matchGlob(filename, skip);
    } else {
      t = filename === skip;
    }
    if (t) {
      return true;
    }
  }
  return false;
};
cdoc.processDir = function(dir, target, skip){
  var index, i$, len$, f, path, name, ext, mkd, targetPath;
  skip == null && (skip = []);
  index = readdirSync(dir);
  if (!existsSync(target)) {
    mkdirSync(target);
  }
  for (i$ = 0, len$ = index.length; i$ < len$; ++i$) {
    f = index[i$];
    if (this.isSkippable(f, skip)) {
      this.log("Skipping ignored file " + f);
      continue;
    }
    path = dir + "/" + f;
    this.log("Processing " + path);
    if (this.isDir(path)) {
      this.log("Entering directory " + path);
      this.processDir(path, target + "/" + f, skip);
    } else {
      name = f.split('.').slice(0, -1).join('.');
      ext = f.split('.').slice(-1)[0];
      if (ext !== 'coffee' && ext !== 'ls') {
        this.log("Skipping non-source file " + path);
        continue;
      }
      mkd = this.processFile(path);
      targetPath = target + "/" + name + ".mkd";
      this.log("Writing markdown to " + targetPath);
      writeFileSync(targetPath, mkd, utf8);
    }
  }
};